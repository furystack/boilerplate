---
name: TypeScript Guidelines
description: Type safety, strict typing, NEVER use any, generics, and type guards for the Boilerplate app
globs:
  - '**/*.ts'
  - '**/*.tsx'
alwaysApply: true
---

# TypeScript Guidelines

## Type Safety

### NEVER use `any`

There are no acceptable uses of `any` in this codebase:

```typescript
// ✅ Good - use unknown for truly unknown types
export function processData(data: unknown): string {
  if (typeof data === 'string') {
    return data
  }
  return JSON.stringify(data)
}

// ✅ Good - use generics for flexible types
export function identity<T>(value: T): T {
  return value
}

// ❌ FORBIDDEN - using any
export function processData(data: any): string {
  return data.toString()
}
```

### Alternatives to `any`

When you think you need `any`, use these instead:

1. **`unknown`** - For truly unknown types that need runtime checking
2. **Generics** - For flexible, type-safe functions
3. **Union types** - For known possible types
4. **Type guards** - For runtime type checking
5. **Utility types** - For transforming existing types

```typescript
// ✅ Good - unknown with type guard
const processValue = (value: unknown) => {
  if (typeof value === 'string') {
    return value.toUpperCase()
  }
  if (typeof value === 'number') {
    return value * 2
  }
  throw new Error('Unsupported type')
}

// ✅ Good - generics
const identity = <T>(value: T): T => {
  return value
}

// ✅ Good - union types
const processInput = (input: string | number | boolean) => {
  if (typeof input === 'string') return input.toUpperCase()
  if (typeof input === 'number') return input * 2
  return !input
}

// ✅ Good - Record for object with unknown keys
const processConfig = (config: Record<string, unknown>) => {
  // Process configuration
}
```

### Explicit Types for Public APIs

All exported functions and public methods should have explicit types:

```typescript
// ✅ Good - explicit types
export async function getCurrentUser(): Promise<User | null> {
  // Implementation
}

export class SessionService {
  public async login(credentials: LoginCredentials): Promise<LoginResult> {
    // Implementation
  }
}

// ❌ Avoid - implicit return types for public APIs
export async function getCurrentUser() {
  // Return type is inferred - not ideal for public APIs
}
```

## Type Definitions

### Prefer `type` over `interface`

```typescript
// ✅ Good
type UserProps = {
  name: string
  email: string
}

type ApiResponse<T> = {
  data: T
  status: number
}

// ❌ Avoid
interface UserProps {
  name: string
  email: string
}
```

### Component Props Types

- **Prefer `type` over `interface`** for type definitions
- Let TypeScript infer return types for simple components
- Include types in the same file as the component they belong to
- Only create separate type files for shared types used across multiple components

```typescript
// ✅ Good - let TypeScript infer return type
type ButtonProps = {
  variant?: 'contained' | 'outlined' | 'text';
  color?: 'primary' | 'secondary' | 'error';
  disabled?: boolean;
  onclick?: () => void;
};

export const Button = Shade<ButtonProps>({
  shadowDomName: 'app-button',
  render: ({ props }) => {
    const variant = props.variant ?? 'contained';
    const color = props.color ?? 'primary';

    return (
      <button
        type="button"
        disabled={props.disabled}
        onclick={props.onclick}
        style={{
          backgroundColor: color === 'primary' ? '#2196f3' : '#f50057',
          opacity: props.disabled ? 0.5 : 1,
        }}
      >
        {/* Button content */}
      </button>
    );
  },
});

// ✅ Good - explicit return type for complex conditional logic
export const StatusBadge = Shade<{ status: string }>({
  shadowDomName: 'status-badge',
  render: ({ props }): JSX.Element | null => {
    switch (props.status) {
      case 'active':
        return <div>Active</div>;
      case 'inactive':
        return <div>Inactive</div>;
      case 'pending':
        return <div>Pending</div>;
      default:
        return null; // Easier to specify return type than cast in each case
    }
  },
});

// ❌ Avoid - using interface (prefer type)
interface ButtonProps {
  variant?: string;
}
```

### Type Organization

- Include component-specific types in the same file as the component
- Create separate type files only for shared types used across multiple components
- Use descriptive names for types
- Group related types together

```typescript
// ✅ Good - types in source file
type UserProfileProps = {
  user: User
  onEdit?: (user: User) => void
  onDelete?: (userId: string) => void
}

export const UserProfile = Shade<UserProfileProps>({
  shadowDomName: 'user-profile',
  render: ({ props }) => {
    // Component implementation
  },
})

// ✅ Good - shared types in separate file
// common/src/models/user.ts
export type User = {
  id: string
  name: string
  email: string
  role: 'admin' | 'user' | 'guest'
}

export type UserProfile = User & {
  avatar?: string
  preferences: UserPreferences
}

export type UserPreferences = {
  theme: 'light' | 'dark'
  language: string
  notifications: boolean
}
```

## API Type Safety

### Using the BoilerplateApi Type

The `common` package defines the API contract. Always import and use it:

```typescript
// ✅ Good - typed API client
import type { BoilerplateApi } from 'common'

const client = new RestClient<BoilerplateApi>({
  baseUrl: '/api',
})

// Type-safe API calls
const user = await client.call({ method: 'GET', action: '/currentUser' })
```

### REST Service Endpoints

Use the typed API definition when creating endpoints:

```typescript
// ✅ Good - typed REST service
import type { BoilerplateApi } from 'common'

useRestService<BoilerplateApi>({
  injector,
  api: {
    GET: {
      '/currentUser': GetCurrentUser,
      '/isAuthenticated': IsAuthenticated,
    },
    POST: {
      '/login': LoginAction,
      '/logout': LogoutAction,
    },
  },
})
```

## Generic Components

### Generic Type Patterns

- Use generics for flexible component types
- Provide proper TypeScript constraints
- Use descriptive generic parameter names

```typescript
// ✅ Good
type ListProps<T> = {
  items: T[];
  renderItem: (item: T, index: number) => JSX.Element;
  keyExtractor: (item: T) => string;
};

export const List = <T,>(props: ListProps<T>) => Shade({
  shadowDomName: 'generic-list',
  render: () => {
    return (
      <ul data-testid="list">
        {props.items.map((item, index) => (
          <li key={props.keyExtractor(item)}>
            {props.renderItem(item, index)}
          </li>
        ))}
      </ul>
    );
  },
});

// ❌ Avoid - not generic when it should be
type ListProps = {
  items: any[];
  renderItem: (item: any) => JSX.Element;
};
```

### Generic Constraints

- Use constraints to limit generic types
- Provide meaningful constraints for type safety
- Use `extends` keyword for type constraints

```typescript
// ✅ Good - with constraints
type DataItem = {
  id: string;
  name: string;
};

type DataListProps<T extends DataItem> = {
  items: T[];
  onItemClick: (item: T) => void;
};

export const DataList = <T extends DataItem>(props: DataListProps<T>) => Shade({
  shadowDomName: 'data-list',
  render: () => {
    return (
      <div data-testid="data-list">
        {props.items.map(item => (
          <div key={item.id} onclick={() => props.onItemClick(item)}>
            {item.name}
          </div>
        ))}
      </div>
    );
  },
});

// ❌ Avoid - no constraints when needed
type DataListProps<T> = {
  items: T[];
  onItemClick: (item: T) => void;
};
```

## Union Types and Discriminated Unions

- Use union types for multiple possible values
- Use discriminated unions for complex state
- Provide proper type guards

```typescript
// ✅ Good - discriminated union
type CacheState<T> =
  | { status: 'idle' }
  | { status: 'loading' }
  | { status: 'loaded'; value: T }
  | { status: 'error'; error: string }

@Injectable({ lifetime: 'singleton' })
export class DataService {
  private dataState = new ObservableValue<CacheState<Data>>({ status: 'idle' })

  public async loadData() {
    this.dataState.setValue({ status: 'loading' })
    try {
      const data = await this.fetchData()
      this.dataState.setValue({ status: 'loaded', value: data })
    } catch (error) {
      this.dataState.setValue({
        status: 'error',
        error: (error as Error).message,
      })
    }
  }
}

// Usage with type narrowing
const state = dataState.getValue()

if (state.status === 'loaded') {
  // TypeScript knows state.value is available
  console.log(state.value)
}

// ❌ Avoid - no discriminator
type CacheState<T> = {
  loading: boolean
  error?: string
  data?: T
}
```

## Type Guards

### Provide Type Guards for Runtime Checks

```typescript
// ✅ Good - type guard
export function isUser(value: unknown): value is User {
  return (
    typeof value === 'object' && value !== null && 'username' in value && typeof (value as User).username === 'string'
  )
}

// Usage
if (isUser(data)) {
  console.log(data.username) // TypeScript knows data is User
}
```

### Array Type Guards

```typescript
// ✅ Good - array type guards
const isStringArray = (value: unknown): value is string[] => {
  return Array.isArray(value) && value.every((item) => typeof item === 'string')
}

const isUserArray = (value: unknown): value is User[] => {
  return Array.isArray(value) && value.every(isUser)
}
```

## Type Utilities

### Utility Types

- Use TypeScript utility types for common patterns
- Create custom utility types when needed
- Leverage built-in utility types

```typescript
// ✅ Good - using utility types
type User = {
  id: string
  name: string
  email: string
  password: string
  role: string
}

// Partial for optional fields
type PartialUser = Partial<User>

// Pick for specific fields
type UserCredentials = Pick<User, 'email' | 'password'>

// Omit for excluding fields
type PublicUser = Omit<User, 'password'>

// Record for object types
type UserMap = Record<string, User>

// Required for making all fields required
type RequiredUser = Required<Partial<User>>

// Readonly for immutable types
type ImmutableUser = Readonly<User>
```

### Custom Utility Types

- Create reusable utility types
- Use descriptive names for custom types
- Document complex utility types

```typescript
// ✅ Good - custom utility types

/**
 * Makes all properties of T deeply partial
 */
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]
}

/**
 * Extracts the return type of an async function
 */
type AsyncReturnType<T extends (...args: unknown[]) => Promise<unknown>> = T extends (
  ...args: unknown[]
) => Promise<infer R>
  ? R
  : never

/**
 * Makes specific properties required
 */
type RequireKeys<T, K extends keyof T> = T & Required<Pick<T, K>>

// Usage
type UserWithRequiredEmail = RequireKeys<Partial<User>, 'email'>
```

## Observable Types

### Type Observable Values

Always provide explicit types for ObservableValue:

```typescript
// ✅ Good - explicit observable type
public currentUser = new ObservableValue<User | null>(null);
public isLoading = new ObservableValue<boolean>(false);
public errors = new ObservableValue<string[]>([]);

// ❌ Avoid - relying on inference for complex types
public currentUser = new ObservableValue(null); // Type is ObservableValue<null>
```

## TypeScript Best Practices

### Type Inference

- **Let TypeScript infer types when possible** - TypeScript's inference is powerful
- Use explicit types strategically for:
  - Public APIs where you want to enforce a contract
  - Complex conditional logic (switch/case) where explicit types are clearer than casting
  - When inference would be ambiguous or incorrect
  - When it significantly improves error messages
- Avoid unnecessary type annotations

```typescript
// ✅ Good - let TypeScript infer
const users = ['Alice', 'Bob', 'Charlie']; // Inferred as string[]
const count = users.length; // Inferred as number
const hasUsers = users.length > 0; // Inferred as boolean

// ✅ Good - infer component return types when straightforward
export const SimpleComponent = Shade<{ title: string }>({
  shadowDomName: 'simple-component',
  render: ({ props }) => {
    return <div>{props.title}</div>; // Return type inferred
  },
});

// ✅ Good - explicit for public APIs
export const createUser = (userData: CreateUserData): Promise<User> => {
  // Explicit return type enforces contract
};

// ✅ Good - explicit for complex conditional logic
export const getStatusDisplay = (status: Status): JSX.Element | null => {
  // Easier to specify return type than cast in each branch
  switch (status) {
    case 'active':
      return <div>Active</div>;
    case 'inactive':
      return <div>Inactive</div>;
    case 'pending':
      return <div>Pending</div>;
    default:
      return null;
  }
};

// ❌ Avoid - unnecessary annotations
const count: number = 5;
const name: string = 'John';
const isActive: boolean = true;
```

### Type Assertions

- Use type assertions sparingly
- Prefer type guards over type assertions
- Use `as const` for literal types

```typescript
// ✅ Good - as const for literal types
const colors = ['red', 'green', 'blue'] as const
type Color = (typeof colors)[number] // 'red' | 'green' | 'blue'

const config = {
  apiUrl: 'https://api.example.com',
  timeout: 5000,
} as const

// ✅ Good - type assertion when necessary
const element = document.getElementById('my-element') as HTMLInputElement

// ✅ Good - with null check
const element = document.getElementById('my-element')
if (element) {
  const input = element as HTMLInputElement
  input.value = 'test'
}

// ❌ Avoid - unnecessary assertion
const value = 'hello' as string

// ❌ Avoid - dangerous assertion
const value = unknownValue as User // Prefer type guard
```

### Non-Null Assertion Operator

- Avoid using `!` operator when possible
- Prefer optional chaining and nullish coalescing
- Use type guards for null checks

```typescript
// ✅ Good - optional chaining
const userName = user?.name ?? 'Anonymous'

// ✅ Good - type guard
if (user) {
  console.log(user.name)
}

// ⚠️ Use sparingly - non-null assertion
const element = document.getElementById('my-element')!

// ❌ Avoid - dangerous non-null assertion
const user = maybeUser! // Can cause runtime error
```

### Strict Null Checks

### Handle Null and Undefined Explicitly

```typescript
// ✅ Good - explicit null handling
export async function getUser(id: string): Promise<User | null> {
  const user = await fetchUser(id)
  if (!user) {
    return null
  }
  return user
}

// ✅ Good - use optional chaining
const userName = user?.name ?? 'Unknown'

// ❌ Avoid - ignoring potential null
const userName = user.name // Error if user is null
```

## Injectable Services and DI

### Service Type Safety

- Use proper typing for injected dependencies
- Leverage TypeScript's type system with dependency injection

```typescript
// ✅ Good - properly typed service
@Injectable({ lifetime: 'singleton' })
export class UserService {
  @Injected(ApiClient)
  declare private apiClient: ApiClient

  @Injected(LoggerService)
  declare private logger: LoggerService

  public async getUser(id: string): Promise<User> {
    try {
      const { result } = await this.apiClient.call({
        method: 'GET',
        action: '/users/:id',
        url: { id },
        query: {},
      })
      return result
    } catch (error) {
      this.logger.error({ message: 'Failed to get user', data: { id, error } })
      throw error
    }
  }
}

// ❌ Avoid - untyped dependencies
@Injectable({ lifetime: 'singleton' })
export class UserService {
  private apiClient: any // Don't do this
}
```

## Summary

**Key Principles:**

1. **NEVER use `any`** - Use `unknown`, generics, or proper types
2. **Explicit types for exports** - Document the contract
3. **Prefer `type` over `interface`**
4. **Type component props** - Every Shade component should have typed props
5. **Use the API type** - Import `BoilerplateApi` from `common`
6. **Type observables** - Always provide explicit types for ObservableValue
7. **Use type guards** for runtime type checking
8. **Leverage utility types** for common patterns
9. **Use discriminated unions** for complex state
10. **Handle nulls** - Use strict null checks and optional chaining

**Type Safety Checklist:**

- [ ] No `any` types anywhere
- [ ] All exported functions have explicit return types
- [ ] Component props are typed
- [ ] API calls use the `BoilerplateApi` type
- [ ] Observable values have explicit types
- [ ] Null/undefined handled explicitly
- [ ] Type guards are used for runtime checking
- [ ] Generic types have proper constraints

**Tools:**

- Type checking: `yarn build`
- Strict mode: Enabled in `tsconfig.json`
